# Задача №1: Контекстная реклама

В современном мире реклама стала частью повседневной жизни, но сейчас, в век прогрессивных технологий, необходимы ваши идеи, как сделать рекламу лучше!

В данной задаче мы рассмотрим упрощенную схему контекстной рекламы. Вам дан текст, состоящий ровно из `n` слов. Стандартный рекламный баннер имеет ровно `r` строк, в каждую из которых может быть записано не более, чем `c` символов. Потенциальным покупателям всегда нравится, когда они могут увидеть много рекламы, поэтому вам нужно определить, какое максимальное число подряд идущих слов из текста можно записать на баннер. 

Отдельные слова в одной строке баннера должны быть разделены между собой пробелами. Допускается ставить больше, чем один пробел подряд. Обратите внимание, что запрещено разрывать слова, то есть каждое отображаемое слово должно быть отображено ровно в одной строке баннера. Помимо этого, запрещено менять порядок слов, то есть, если читать текст баннера последовательно от верхних строк к нижним и в каждой строке слева направо, должен получаться некоторый последовательный отрывок из текста рекламы.

### Входные данные
В первой строке входных данных записано три целых числа `n`, `r`, `c`:

- `n` — количество слов в тексте (1 ≤ n ≤ 10^6)
- `r` — количество строк на баннере (1 ≤ r ≤ 10^6)
- `c` — количество символов в каждой строке (1 ≤ c ≤ 10^6)
  
Суммарное количество символов во всех словах не превышает `5 * 10^6`.

Во второй строке записан текст — `n` слов. Слова состоят только из строчных латинских букв и не являются пустыми. Слова в строке разделяются единичными пробелами.

### Выходные данные
Выведите не более `r` строк, в каждой из которых выведите не более, чем `c` символов — оптимальный рекламный баннер. Если существует несколько оптимальных баннеров, выведите любой.

Обратите внимание, что некоторые строки баннера могут быть пустыми. Такие строки разрешается не выводить.

### Примеры

**Входные данные 1**:
```
9 4 12
this is a sample text for croc final round
```

**Выходные данные 1**:
```
this is a
sample text
for croc
final round
```

**Входные данные 2**:
```
9 1 9
this is a sample text for croc final round
```

**Выходные данные 2**:
```
this is a
```

**Входные данные 3**:
```
6 2 3
croc a a a croc a
```

**Выходные данные 3**:
```
a a
a
```

**Входные данные 4**:
```
2 2 5
first second
```

**Выходные данные 4**:
```
first
second
```

---


# Задача №2: Оптимизация REST API с лимитами запросов и мониторингом использования ресурсов

Вы разрабатываете высоконагруженный REST API-сервис, который обслуживает тысячи клиентов одновременно. Система должна эффективно обрабатывать запросы клиентов с соблюдением ограничений по количеству запросов в минуту (Rate Limiting) и оптимизировать использование ресурсов (CPU, память). Программа должна поддерживать мониторинг потребления памяти и загрузки CPU, а также быть готова к работе под нагрузкой на длительных временных отрезках.

### Условия задачи (для выполнения):

1. **Ограничения по запросам**: 
   - Каждый клиент может делать **не более 100 запросов в минуту**.
   - Если клиент превышает лимит, ему возвращается ошибка **429 (Too Many Requests)** и указание, через сколько времени можно снова отправлять запросы.
   - Лимит запросов может быть изменен для разных клиентов (например, VIP-клиенты могут иметь лимит в 1000 запросов в минуту).
   
2. **Мониторинг производительности**:
   - Программа должна собирать и отображать статистику по использованию ресурсов (память и процессор) для контроля эффективности работы.
   - **Мониторинг должен быть встроен в приложение (на стороне сервера, СЕ проверяет)** для наблюдения за расходом ресурсов в реальном времени, чтобы разработчики могли отслеживать потребление памяти и загрузку CPU.
   
3. **Оптимизация под высокую нагрузку**:
   - Программа должна работать стабильно при большом количестве запросов (до 1 миллиона запросов в минуту, на стороне сервера, СЕ проверяет).
   - Приложение должно быть оптимизировано по времени выполнения и использованию памяти: не более `O(n)` по времени для каждого запроса и использование `O(1)` дополнительной памяти (кроме хранения данных о клиентах).

4. **Мониторинг работы REST API**:
   - Необходимо реализовать систему мониторинга и оповещений, которая будет отслеживать, когда нагрузка на сервер (память или CPU) превышает допустимые лимиты.
   - При превышении лимитов система должна отправлять уведомления разработчикам.

### Задача:

Разработайте REST API-сервис с поддержкой Rate Limiting, оптимизированный для работы под высокой нагрузкой, с мониторингом ресурсов и системой оповещений о перегрузке. Программа должна следить за использованием памяти и загрузкой процессора.

### Расширенное описание задачи:

#### 1. Реализация системы Rate Limiting

1.1. **Структура данных для хранения информации о клиентах**:
   - Используйте хеш-таблицу для хранения информации о каждом клиенте: время последнего запроса и количество запросов за текущий период (например, текущую минуту).
   - Обновляйте информацию о запросах и проверяйте лимиты для каждого клиента.
   - Динамическое изменение лимитов в зависимости от типа клиента (обычный клиент, VIP и т.д.).

1.2. **Формула для проверки лимита запросов**:
   Для каждого запроса проверяется, не превышен ли лимит. Если количество запросов за последнюю минуту больше разрешенного, возвращается ошибка:
   
 ![image](https://github.com/user-attachments/assets/15d0cd7e-7dce-486d-9e02-f219c0970b59)

   Где:
   - `request_count` — количество запросов клиента за последнюю минуту,
   - `limit` — установленный лимит запросов для данного клиента,
   - `last_request_time` — время последнего запроса.

#### 2. Оптимизация использования памяти и времени

2.1. **Очистка старых данных**:
   - Для экономии памяти необходимо периодически очищать данные о клиентах, которые не отправляли запросы в течение последних 5 минут.
   - Используйте **LRU-кэш** для хранения информации о клиентах, чтобы удалять записи о тех, кто долгое время не отправлял запросы.

2.2. **Мониторинг использования памяти**:
   - Включите в программу сбор данных о потребляемой памяти для того, чтобы отслеживать, как система работает под нагрузкой.
   - Используйте специальные инструменты для мониторинга (например, плагины для Visual Studio Code) и предоставляйте информацию разработчикам в реальном времени.

#### 3. Мониторинг использования CPU и памяти

3.1. **Сбор статистики**:
   - Включите мониторинг статистики по использованию памяти и загрузке процессора. Используйте подходящие библиотеки для Node.js или Python (например, **`os`** для получения информации о системе).
   - Собирайте информацию о пиковых значениях загрузки CPU и памяти в интервалах времени (например, каждые 5 секунд).

3.2. **Плагины для Visual Studio Code**:
   - Используйте следующие плагины для мониторинга:
     - **CodeMetrics** — для оценки сложности кода и потенциальных проблем с производительностью.
     - **REST Client** — для тестирования и мониторинга запросов к API.
     - **Node.js Memory Usage** — для отслеживания использования памяти в Node.js приложениях.
     - **Process Explorer** — для мониторинга процессов и системных ресурсов, включая CPU и память.

3.3. **Система оповещений**:
   - Когда память или CPU превышают заданные лимиты, система должна отправить уведомления (например, через email или Slack). Настройте интеграцию с оповещениями через такие сервисы, как **Grafana**, **Prometheus**, или **AWS CloudWatch**.

#### 4. Формула для расчета производительности:

Для анализа использования ресурсов в вашем приложении нужно вычислить нагрузку на процессор и потребление памяти. Формулы для мониторинга включают следующие показатели:

4.1. **Загрузка CPU**:
   Загрузка CPU рассчитывается как процент от общего времени работы процессора, которое занято выполнением вашей программы.
   
   ![image](https://github.com/user-attachments/assets/e378a3a2-872f-4ec2-bc84-d54b3517d6e4)


4.2. **Использование памяти**:
   Память рассчитывается как количество памяти, занимаемой процессом, делённое на общую доступную память:
   
   ![image](https://github.com/user-attachments/assets/01ac83ca-3997-48a8-8ae6-cf1e671f2a6b)


#### 5. Профилирование приложения

5.1. **Тестирование под нагрузкой**:
   - С помощью инструментов преподавателя, таких как **k6**, будет проводено тестирование под высокой нагрузкой, чтобы проверить, как система справляется с миллионами запросов в минуту.

5.2. **Оптимизация кода**:
   - Проведите анализ времени выполнения кода и профилирование, чтобы определить узкие места в использовании ресурсов и оптимизировать их.

---

### Плагин для Visual Studio Code для мониторинга ресурсов:

Для мониторинга памяти и загрузки процессора можно использовать следующие плагины:

1. **Node.js Memory Usage**:
   - Показывает использование памяти в реальном времени для приложений, написанных на Node.js.
   - Полезен для отслеживания потребления памяти в ваших API, чтобы убедиться, что приложение не выходит за рамки выделенных ресурсов.

2. **Process Explorer**:
   - Отображает все запущенные процессы и ресурсы, которые они потребляют.
   - С помощью этого плагина можно наблюдать, сколько CPU и памяти используется приложением прямо из Visual Studio Code.

3. **REST Client**:
   - Позволяет тестировать API прямо в Visual Studio Code, без необходимости использования внешних инструментов, таких как Postman. Позволяет следить за временем ответа и успешностью обработки запросов.

4. **CodeMetrics**:
   - Анализирует сложность кода и предоставляет метрики, которые помогут вам найти участки, требующие оптимизации для повышения производительности.
